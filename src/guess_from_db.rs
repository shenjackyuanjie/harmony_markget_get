pub mod config;
pub mod db;
pub mod model;
pub mod server;
pub mod sync;
pub mod utils;

use std::collections::BTreeSet;

use anyhow::Context;
use colored::Colorize;

use model::query::AppQuery;

use crate::sync::code::GLOBAL_CODE_MANAGER;

fn main() -> anyhow::Result<()> {
    utils::init_log();
    let rt = tokio::runtime::Builder::new_multi_thread()
        .worker_threads(8)
        .enable_all()
        .build()
        .with_context(|| "Failed to create tokio runtime")?;

    rt.block_on(async_main())
}

async fn async_main() -> anyhow::Result<()> {
    // 加载配置
    let config = config::Config::load().with_context(|| "Failed to load config")?;

    // 连接数据库
    let db = crate::db::Database::new(config.database_url(), config.db_max_connect()).await?;

    let _token = GLOBAL_CODE_MANAGER.update_token().await;

    // 获取数据库中所有的 app_id
    println!("正在从数据库获取所有 app_id...");
    let existing_app_ids = db.get_all_app_ids().await?;
    let existing_app_ids = existing_app_ids
        .iter()
        .filter(|i| i.starts_with("C69175"))
        .cloned()
        .collect::<Vec<_>>();
    println!("从数据库获取到 {} 个 app_id", existing_app_ids.len());

    if existing_app_ids.is_empty() {
        println!("数据库中没有找到任何 app_id, 无法进行猜测");
        return Ok(());
    }

    // 解析 app_id 格式并生成需要猜测的范围
    let mut all_ranges: BTreeSet<(String, u64, u64)> = BTreeSet::new();

    for app_id in existing_app_ids {
        if let Some((prefix, numeric_part)) = parse_app_id(&app_id) {
            let start_range = numeric_part.saturating_sub(1000);
            let end_range = numeric_part.saturating_add(1000);
            all_ranges.insert((prefix, start_range, end_range));
        }
    }

    println!("生成了 {} 个唯一的前缀范围", all_ranges.len());

    // 按前缀分组并合并范围
    let mut ranges_by_prefix = std::collections::HashMap::new();

    for (prefix, start, end) in all_ranges {
        ranges_by_prefix
            .entry(prefix)
            .or_insert_with(Vec::new)
            .push((start, end));
    }

    // 合并每个前缀的重叠范围
    let mut merged_ranges = Vec::new();

    for (prefix, mut ranges) in ranges_by_prefix {
        // 按起始位置排序
        ranges.sort_by_key(|&(start, _)| start);

        let mut merged = Vec::new();
        let mut current_range = ranges[0];

        for &range in &ranges[1..] {
            if range.0 <= current_range.1 + 1 {
                // 范围重叠或相邻，合并
                current_range.1 = current_range.1.max(range.1);
            } else {
                // 不重叠，保存当前范围并开始新的范围
                merged.push(current_range);
                current_range = range;
            }
        }
        merged.push(current_range);

        for (start, end) in merged {
            merged_ranges.push((prefix.clone(), start, end));
        }
    }

    println!("合并后得到 {} 个范围", merged_ranges.len());

    let client = reqwest::ClientBuilder::new()
        .timeout(std::time::Duration::from_secs(config.api_timeout_seconds()))
        .build()
        .with_context(|| "Failed to create reqwest client")?;

    let batch = 1000;
    let wait_time = std::time::Duration::from_millis(50);

    // 处理每个合并后的范围
    for (prefix, start_range, end_range) in merged_ranges {
        println!(
            "开始处理前缀 {} 的范围 {}..{}",
            prefix, start_range, end_range
        );

        let total_ids = end_range - start_range + 1;
        println!("需要处理 {} 个 ID", total_ids);

        for chunk_start in (start_range..=end_range).step_by(batch) {
            let chunk_end = (chunk_start + batch as u64 - 1).min(end_range);
            let chunk_size = chunk_end - chunk_start + 1;

            println!(
                "处理批次: {} - {} ({} 个 ID)",
                chunk_start, chunk_end, chunk_size
            );

            let mut join_set = tokio::task::JoinSet::new();

            for id in chunk_start..=chunk_end {
                let client = client.clone();
                let db = db.clone();
                let api_url = config.api_url().to_string();
                let locale = config.locale().to_string();
                let app_id = format!("{}{}", prefix, id);
                let comment = serde_json::json!({"user": format!("guess_from_db-{}", env!("CARGO_PKG_VERSION"))});

                join_set.spawn(async move {
                    if let Ok(data) = crate::sync::query_app(
                        &client,
                        &api_url,
                        &AppQuery::app_id(&app_id),
                        &locale,
                    )
                    .await
                    {
                        match db
                            .save_app_data(&data.0, data.1.as_ref(), None, Some(comment))
                            .await
                        {
                            Ok(inserted) => {
                                println!(
                                    "{}{}{}",
                                    if inserted.0 {
                                        format!("已将 {app_id} 的基本插入数据库\n")
                                            .on_green()
                                            .to_string()
                                    } else {
                                        "".to_string()
                                    },
                                    if inserted.1 {
                                        format!("已将 {app_id} metrics\n").on_green().to_string()
                                    } else {
                                        "".to_string()
                                    },
                                    if inserted.2 {
                                        format!("已将 {app_id} 的评分数据插入数据库")
                                            .on_green()
                                            .to_string()
                                    } else {
                                        "".to_string()
                                    }
                                );
                            }
                            Err(err) => {
                                println!(
                                    "{}",
                                    format!("保存 {app_id} 的数据时出错: {}", err).on_red()
                                );
                            }
                        }
                    }
                });
            }

            join_set.join_all().await;
            println!(
                "批次 {} - {} 处理完成，等待 {:?}",
                chunk_start, chunk_end, wait_time
            );
            tokio::time::sleep(wait_time).await;
        }
    }

    println!("所有范围处理完成!");
    Ok(())
}

/// 解析 app_id，返回前缀和数字部分
fn parse_app_id(app_id: &str) -> Option<(String, u64)> {
    // app_id 格式通常是 "C5765880207856366961"
    // 我们需要分离前缀和数字部分

    // 找到第一个数字的位置
    let first_digit_pos = app_id.find(|c: char| c.is_ascii_digit())?;

    // 找到最后一个数字的位置
    let last_digit_pos = app_id.rfind(|c: char| c.is_ascii_digit())?;

    let prefix = app_id[..first_digit_pos].to_string();
    let numeric_str = &app_id[first_digit_pos..=last_digit_pos];

    numeric_str.parse().ok().map(|num| (prefix, num))
}
